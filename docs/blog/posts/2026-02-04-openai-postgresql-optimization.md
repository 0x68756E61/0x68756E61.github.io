---
title: "RDB의 한계 돌파: OpenAI의 PostgreSQL 단일 노드 극한 최적화 & 아키텍처 분석"
date: 2026-02-04
authors:
  - '0x68756E61'
categories:
  - Engineering
tags:
  - postgresql
  - database
  - openai
  - architecture
  - backend
---

![](../../assets/images/2026-02-04-openai-postgres-optimization-hero.png)

> "서비스 트래픽이 폭주하고 있습니다. DB가 한계입니다. 당장 샤딩(Sharding)부터 도입해야 할까요?" 2023년, 역사상 가장 빠르게 성장한 서비스인 ChatGPT를 운영하는 OpenAI의 백엔드 엔지니어들도 똑같은 고민에 직면했습니다.

<!-- more -->

"서비스 트래픽이 폭주하고 있습니다. DB가 한계입니다. 당장 샤딩(Sharding)부터 도입해야 할까요?"

2023년, 역사상 가장 빠르게 성장한 서비스인 ChatGPT를 운영하는 OpenAI의 백엔드 엔지니어들도 똑같은 고민에 직면했습니다. 수억 명의 사용자가 동시에 질문을 쏟아내는 상황에서, 일반적인 선택은 수평 확장(Sharding)이나 최신 NoSQL로의 이주였을 것입니다. 하지만 그들의 선택은 우리의 예상과 정반대였습니다.

그들은 30년 된 오픈소스 RDBMS인 PostgreSQL의 단일 노드(Single Master) 구조를 끝까지 고수했습니다. 왜 그들은 '확장성의 정석'이라 불리는 샤딩을 거부했을까요? 그리고 어떻게 단 하나의 마스터 노드로 전 세계 8억 명의 트래픽을 감당해 냈을까요? OpenAI가 '복잡함'이라는 유혹을 뿌리치고 '단순함'의 미학으로 극한의 성능을 짜낸 아키텍처 전략을 개발자 관점에서 깊이 있게 파헤쳐 봅니다.

## 1. 아키텍처 철학: "Just Scale Up" (샤딩 없는 세상)

OpenAI 데이터베이스 아키텍처의 핵심은 **단순함(Simplicity)**입니다. 그들은 Azure Managed PostgreSQL을 사용하며, **1개의 쓰기 전용 주 서버(Primary)**와 **50개 이상의 읽기 전용 복제본(Read Replicas)**으로 클러스터를 구성했습니다.

**왜 샤딩(Sharding)을 하지 않았나?**
개발자라면 샤딩이 가져오는 '운영의 지옥'을 알고 있을 것입니다.

*   **복잡한 트랜잭션**: 샤딩된 환경에서는 2-Phase Commit 등 분산 트랜잭션 관리가 매우 까다롭습니다.
*   **Join의 상실**: 여러 물리 서버로 데이터가 쪼개지면, 단순한 JOIN 쿼리조차 애플리케이션 레벨에서 데이터를 긁어모아 처리해야 합니다.
*   **재분배(Resharding) 이슈**: 특정 샤드에 데이터가 몰리는 'Hotspot'이 발생하면, 서비스 중에 데이터를 다시 쪼개서 옮기는 위험천만한 작업을 수행해야 합니다.

OpenAI는 이러한 복잡성을 제거하고 ACID 트랜잭션의 강력한 일관성을 유지하기 위해, 샤딩 대신 단일 노드를 극한으로 튜닝하는 길을 택했습니다.

## 2. 연결 관리: 계층형 커넥션 풀링 (Hierarchical Connection Pooling)

수천 개의 Kubernetes Pod가 오토스케일링 되는 환경에서, PostgreSQL의 프로세스 기반(Process-based) 연결 모델은 치명적입니다. 연결 하나당 OS 프로세스가 생성되므로, 연결 폭주는 곧 메모리 고갈(OOM)로 이어집니다. 이를 해결하기 위해 OpenAI는 단순히 PgBouncer를 쓰는 것을 넘어, N-Tier 풀링 전략을 구사했습니다.

*   **L1 (App Side)**: 각 애플리케이션 Pod 내부에 가벼운 PgBouncer 사이드카(Sidecar)를 배치하여 앱과 프록시 간의 오버헤드를 최소화합니다.
*   **L2 (DB Side)**: 데이터베이스 앞단에 중앙 집중식 PgBouncer를 배치하여 실제 DB로 유입되는 물리적 연결(Physical Connection) 개수를 엄격하게 제한합니다.

💡 **Effect**: 수천 개의 Pod가 배포되고 사라져도(Churn), 실제 DB는 항상 일정 수준(예: 100~200개)의 연결만 유지하므로 컨텍스트 스위칭 비용이 획기적으로 줄어듭니다.

## 3. 쓰기(Write) 병목 해결: RDB를 '메타데이터 저장소'로

단일 마스터 구조의 최대 약점은 **쓰기 처리량(Throughput)**의 물리적 한계입니다. OpenAI는 이를 극복하기 위해 IOPS를 획기적으로 줄이는 전략을 사용했습니다.

### 3.1. Blob Offloading (TOAST 문제 해결)
PostgreSQL은 긴 텍스트를 저장할 때 TOAST(The Oversized-Attribute Storage Technique) 테이블을 사용합니다. 하지만 채팅 로그 같은 대용량 텍스트가 DB 버퍼 캐시를 점유하면 성능이 급락합니다.

*   **전략**: 텍스트 데이터나 이미지 같은 'Payload'는 S3/Azure Blob Storage로 즉시 빼냅니다.
*   **RDB 역할**: PostgreSQL에는 해당 데이터의 URL(Pointer)과 메타데이터만 저장합니다.
*   **결과**: DB 페이지 캐시 적중률(Hit Rate)을 99% 이상으로 유지하여, 대부분의 쿼리를 디스크 I/O 없이 메모리에서 처리합니다.

### 3.2. 지연 쓰기 (Batching)
모든 사용자 이벤트(클릭, 페이지 조회)를 실시간으로 INSERT 하지 않습니다. Kafka나 Redis 같은 인메모리 버퍼에 모았다가, 일정 주기로 COPY 명령어를 통해 대량으로 밀어 넣습니다. 이는 DB의 트랜잭션 오버헤드를 획기적으로 줄여줍니다.

### 3.3. 워크로드 분리 (Polyglot Persistence)
엄격한 트랜잭션이 필요 없는 단순 로그나 분석 데이터는 CosmosDB와 같은 NoSQL로 오프로딩하여 RDB의 부담을 덜어줍니다.

## 4. 읽기(Read) 최적화: 쿼리 킬러와 라우팅

트래픽의 대부분을 차지하는 읽기 요청을 효율적으로 처리하기 위해 애플리케이션 레벨에서 정교한 제어를 수행합니다.

### 4.1. 우선순위 기반 라우팅
모든 읽기 요청이 평등하지 않습니다.
*   **Critical Path (실시간 채팅 응답)**: 복제 지연(Lag)이 거의 없는 고성능 전용 복제본으로 라우팅.
*   **Non-Critical Path (통계, 백그라운드 작업)**: 일반 복제본으로 라우팅.

### 4.2. 쿼리 타임아웃 (Query Killer)
ORM이 실수로 생성한 비효율적인 쿼리(예: 12개 테이블 조인)가 DB 리소스를 점유하는 것을 막기 위해 엄격한 타임아웃을 설정합니다.

```sql
-- 예시 설정: 5초 이상 도는 쿼리는 강제 종료
SET statement_timeout = 5000;
```

개발자에게는 가혹해 보일 수 있지만, 하나의 나쁜 쿼리가 전체 서비스를 마비시키는 것을 방지하는 필수적인 조치입니다.

## 5. 안정성 엔지니어링: Vacuum과 인덱스 관리

대규모 PostgreSQL 운영의 핵심은 **MVCC(Multi-Version Concurrency Control)**에 대한 이해와 관리입니다.

### 5.1. 공격적인 Autovacuum 튜닝
기본 설정의 Autovacuum은 대규모 트래픽에서 너무 게으릅니다(Lazy). 죽은 튜플(Dead Tuple)이 쌓이면 테이블이 비대해져(Bloat) 성능이 저하됩니다. OpenAI는 이를 매우 공격적으로 설정했습니다.

*   `autovacuum_vacuum_scale_factor`: 기본값(0.2, 20%)보다 훨씬 낮게 설정(예: 0.01~0.05)하여, '자주, 조금씩' 청소하도록 유도합니다.

### 5.2. 인덱스 위생 관리 (Index Hygiene)
쓰기 성능을 갉아먹는 주범은 불필요한 인덱스입니다.
*   **Partial Index 활용**: `WHERE status = 'active'`처럼 특정 조건의 데이터만 인덱싱하여 인덱스 크기를 줄입니다.
*   **Non-Blocking 생성**: 인덱스 생성 시 반드시 `CONCURRENTLY` 옵션을 사용하여 서비스 중단을 막습니다.
*   **미사용 인덱스 제거**: 주기적으로 사용되지 않는 인덱스를 모니터링하여 삭제합니다.

## 🚀 결론: 기술은 비즈니스를 위해 존재한다

OpenAI의 사례는 우리에게 중요한 교훈을 줍니다. **"새롭고 화려한 기술보다, 검증된 기술을 깊이 이해하고 최적화하는 것이 더 강력할 수 있다"**는 것입니다. 그들은 PostgreSQL이라는 오래된 도구를 버리는 대신, 그 도구의 한계까지 파고들어 최적화함으로써 8억 명이라는 믿기 힘든 규모를 감당해 냈습니다.

여러분의 서비스가 느려지고 있나요? 복잡한 샤딩이나 마이크로서비스 도입을 고민하기 전에, 현재 사용 중인 데이터베이스의 잠재력을 100% 끌어내고 있는지 먼저 점검해 보시길 바랍니다. 단순함이 복잡함을 이깁니다.

---
참고: 이 글은 OpenAI의 Scaling Kubernetes 및 PostgreSQL 관련 기술 블로그와 엔지니어링 사례 분석을 바탕으로 재구성되었습니다.
